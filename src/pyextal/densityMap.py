from functools import partial

import numpy as np
import matplotlib.pyplot as plt
from skimage.measure import marching_cubes

from pyextal.dinfo import BaseDiffractionInfo, LARBEDDiffractionInfo
from pyextal.roi import LARBEDROI
from pyextal.blochwave import defaultsf, constants, cryst, difpar, gram
from pyextal.metric import scale
from pyextal.callBloch import lookupSF, symmetrizeVHKL, e2Xray


def fourierSynthesis(getSF:callable, order:int, sampling:int) -> np.ndarray:
    """
    Perform Fourier synthesis to generate a 3D density map from the diffraction information.

    Args:
        dinfo (BaseDiffractionInfo): An instance of BaseDiffractionInfo containing the diffraction data.

    Returns:
        np.ndarray: A 3D density map generated from the Fourier synthesis.
    """
    
    densityMap = np.zeros((sampling,sampling,sampling), dtype=np.complex64)
    x, y, z = np.mgrid[:sampling,:sampling,:sampling] / sampling
    for h in range(-order,order+1,1):
        for k in range(-order,order+1,1):
            for l in range(-order,order+1,1):
                if h == 0 and k == 0 and l == 0:continue
                # if h**2 + k**2 + l**2 > 16: continue
                sf = getSF((h,k,l))
                
                densityMap += (sf[0] + 1j*sf[1]) *np.exp(-2*np.pi*1j*(h*x+k*y+l*z))   
    return densityMap.real / constants.vol

def plotDensityMapIsosurface(density_map: np.ndarray, threshold=10) -> None:
    """
    Plot the 3D density map using marching cubes for surface extraction.
    X, Y, Z might be incorrect, check vesta for correct orientation

    Args:
        density_map (np.ndarray): The 3D density map to be visualized.
    """
    # Extract the surface using marching cubes
    verts, faces, _, _ = marching_cubes(density_map, level=threshold)

    # Create a 3D plot
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    
    # Plot the surface
    ax.plot_trisurf(verts[:, 0], verts[:, 1], verts[:, 2], triangles=faces, facecolor='blue', shade=True)
    
    # Set labels
    ax.set_xlabel('X-axis')
    ax.set_ylabel('Y-axis')
    ax.set_zlabel('Z-axis')    
    plt.show()

def poltDensityMap_2D(density_map: np.ndarray, clim:tuple, cmap:str)-> None:
    fig, axes = plt.subplots(nrows=1, ncols=4)
    for i in range(4):    
        axes[i].imshow(density_map[i*16,:,:], vmin=clim[0], vmax=clim[1], cmap=cmap)
        print(np.max(density_map[i*16,:,:]))        
    plt.show()

def write_cube(filename, data):
    """
    Write a simple Gaussian cube file for volumetric data.
    
    :param filename: Output .cube file name
    :param data: 3D NumPy array of charge density values
    :param origin: (x, y, z) tuple for grid origin
    :param spacing: (dx, dy, dz) tuple for grid spacing
    :param atoms: List of tuples [(atomic_number, x, y, z), ...] in Angstroms
    """
    nx, ny, nz = data.shape
    
    with open(filename, "w") as f:
        f.write("Generated by pyextal\n")
        f.write("Charge density data\n")
        
        # Number of atoms and grid origin
        f.write(f"{cryst.natoms:5d} {0.0:12.6f} {0.0:12.6f} {0.0:12.6f}\n")
        
        # Grid dimensions and voxel spacing TODO: non-cubic system
        f.write(f"{nx:5d} {cryst.cell[0]/nx:12.6f} 0.000000 0.000000\n")
        f.write(f"{ny:5d} 0.000000 {cryst.cell[1]/ny:12.6f} 0.000000\n")
        f.write(f"{nz:5d} 0.000000 0.000000 {cryst.cell[2]/nz:12.6f}\n")
        # Atomic positions
        for idx, (x, y, z) in enumerate(cryst.atpar.T[:cryst.natoms,:3]):
            f.write(f"{int(cryst.zt[int(cryst.itype[idx])-1]+0.5):5d} 0.000000 {x:12.6f} {y:12.6f} {z:12.6f}\n")
        
        # Charge density values
        data_flat = data.ravel()
        for i, value in enumerate(data_flat):
            f.write(f"{value:12.5E} ")
            if (i + 1) % 6 == 0:  # 6 values per line
                f.write("\n")


    

# Example usage
if __name__ == "__main__":
    dp = np.load("Larbed/Si_undoped/111_110sys/region1/Store_deconv.npy")
    dp = np.flip(dp,axis=2)
    gindex = np.load("Larbed/Si_undoped/111_110sys/region1/g_vectorsSi.npy")
    variance = np.load("Larbed/Si_undoped/111_110sys/region1/Store_variance.npy")
    variance = np.flip(variance,axis=2)

    dtpar = [0,0,0,0,0]
    background = 0

    dinfo = LARBEDDiffractionInfo(dp,  900,  0, 0, 31.78, 'examples/Si_undoped/si110.dat', dtpar, background,gindex, varianceMaps=variance)
    roi = LARBEDROI(dinfo=dinfo, rotation=0, gx=np.array([1,-1,0]), gInclude=[(0,0,0)]) 


    dinfo.save_hkl('box/Si.hkl', )

    print(defaultsf(1, np.array([0,2,2])))
    # print(lookupSF(([1,1,1],[2,2,0], [1,1,3], [2,2,2], [0,0,4]), IAM=True))
    # # print(difpar.hklf[:3,:difpar.nref].T)
    
    # getSF = partial(dinfo2Xray, getESF=lambda x:lookupSF([x,])[0])
    # getIAMSF = partial(dinfo2Xray, getESF=lambda x:lookupSF([x,], IAM=True)[0])
    # densityMap = fourierSynthesis(getSF, order=4, sampling=64)
    # IAM_densityMap = fourierSynthesis(getIAMSF, order=4, sampling=64)

    # difference = densityMap - IAM_densityMap
    # print(np.sum(densityMap), np.sum(IAM_densityMap))
    # # # # Plot the density map
    # # plotDensityMapIsosurface(densityMap, threshold=10)    
    # # write_cube('box/Si_difference.cube', difference)
    # # write_cube('box/Si.cube', densityMap)
    # poltDensityMap_2D(density_map=densityMap, clim=(0,25), cmap='inferno')
    # poltDensityMap_2D(density_map=difference, clim=(-0.2,0.2), cmap='seismic')

    # plt.figure()
    # profile1 = []
    # profile2 = []
    # profile3 = []
    # for i in range(64):
    #     profile1.append(IAM_densityMap[i,i,i], label='IAM')
    #     profile2.append(densityMap[i,i,i], label='X-ray')
    #     profile3.append(difference[i,i,i])

    # plt.plot(profile1)
    # plt.plot(profile2)
    # plt.show()
    # plt.figure()
    # plt.plot(profile3)
    # plt.show()
